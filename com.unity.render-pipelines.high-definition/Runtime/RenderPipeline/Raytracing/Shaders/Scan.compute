#pragma kernel ScanInit
#pragma kernel ScanMain
#pragma kernel ScanAddBlocksums


//#pragma enable_d3d11_debug_symbols

//#pragma only_renderers d3d11
//#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
//#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
//#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/NormalBuffer.hlsl"
//#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl"
//#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Builtin/BuiltinData.hlsl"
//#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/BSDF.hlsl"
//#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/CommonLighting.hlsl"
//#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/ImageBasedLighting.hlsl"
//#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/PreIntegratedFGD/PreIntegratedFGD.hlsl"
//#include "Packages/com.unity.render-pipelines.high-definition/Runtime/PostProcessing/Shaders/TemporalAntialiasing.hlsl"

// Raytracing Includes
//#include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/OnlineVariance.hlsl"
//#include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RaytracingConsts.hlsl"
//#include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RaytracingSampling.hlsl"
//#include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/ShaderVariablesRaytracing.hlsl"
//#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/ScreenSpaceLighting/ScreenSpaceLighting.hlsl"


//TODO. Find out how to make these 1d buffers that also work in Raytracing/Raygen shaders
RWTexture2D<uint>   _ScanCounts;
RWTexture2D<uint>   _ScanOffsets;
RWTexture2D<uint>   _ScanBlocksums; 
uint                _ScanStoreBlocksums;
uint                _ScanMax;
//int                 _ScanThreadGroupSize;   //128, processing 256 items per thread group

uint2 IndexToCoord(uint idx)
{
    return uint2(idx % 1024, idx / 1024);
}

[numthreads(64, 1, 1)]
void ScanInit(uint3 id : SV_DispatchThreadID)
{
    if (id.x < _ScanMax)
    {
        _ScanCounts[IndexToCoord(id.x)] = 0;
    }
}

groupshared int scanSharedMem[256];	
[numthreads(128, 1, 1)]
void ScanMain(uint3 id : SV_DispatchThreadID)
{
    //TODO, avoid bank conflicts?
    int thid = id.x&127;    //id actually 0-127
    int rwid = (id.x * 2);

    int offset = 1;

    scanSharedMem[2 * thid] = _ScanCounts[IndexToCoord(rwid)].x;
    scanSharedMem[2 * thid + 1] = _ScanCounts[IndexToCoord(rwid+1)].x;

    int finalCount = 0;
    if (thid == 127)
    {
        finalCount = scanSharedMem[255];
    }

    int d;
    for (d = (int)256 >> 1; d > 0; d >>= 1)
    {
        GroupMemoryBarrierWithGroupSync();
        if (thid < d)
        {
            int ai = offset * (2 * thid + 1) - 1;
            int bi = offset * (2 * thid + 2) - 1;
            scanSharedMem[bi] += scanSharedMem[ai];
        }
        offset *= 2;
    }

    if (thid == 0)
        scanSharedMem[255] = 0;

    for (d = 1; d < (int)256; d *= 2)
    {
        offset >>= 1;
        GroupMemoryBarrierWithGroupSync();
        if (thid < d)
        {
            int ai = offset * (2 * thid + 1) - 1;
            int bi = offset * (2 * thid + 2) - 1;
            int t = scanSharedMem[ai];
            scanSharedMem[ai] = scanSharedMem[bi];
            scanSharedMem[bi] += t;
        }
    }
    GroupMemoryBarrierWithGroupSync();

    _ScanOffsets[IndexToCoord(rwid)].x = scanSharedMem[2 * thid];
    _ScanOffsets[IndexToCoord(rwid+1)].x = scanSharedMem[2 * thid + 1];

    if (thid == 127)
    {
        if (_ScanStoreBlocksums)
        {
            _ScanBlocksums[IndexToCoord(id.x / 128)].x = finalCount + scanSharedMem[255];
        }
    }
}

[numthreads(128, 1, 1)]
void ScanAddBlocksums(uint3 id : SV_DispatchThreadID)
{
    int blockSumId = id.x / 256;

    _ScanOffsets[IndexToCoord(id.x)].x += _ScanBlocksums[IndexToCoord(blockSumId)].x;
}


